!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BalloonDeclaration	.\echofunc.vim	/^function! BalloonDeclaration()$/;"	f
BalloonDeclarationStart	.\echofunc.vim	/^function! BalloonDeclarationStart()$/;"	f
BalloonDeclarationStop	.\echofunc.vim	/^function! BalloonDeclarationStop()$/;"	f
CallTagList	.\echofunc.vim	/^function! s:CallTagList(str)$/;"	f
CheckTagsLanguage	.\echofunc.vim	/^function! s:CheckTagsLanguage(filetype)$/;"	f
CheckedBalloonDeclarationStart	.\echofunc.vim	/^function! CheckedBalloonDeclarationStart()$/;"	f
CheckedEchoFuncStart	.\echofunc.vim	/^function! CheckedEchoFuncStart()$/;"	f
EchoFunc	.\echofunc.vim	/^augroup EchoFunc$/;"	a
EchoFunc	.\echofunc.vim	/^function! EchoFunc()$/;"	f
EchoFuncClear	.\echofunc.vim	/^function! EchoFuncClear()$/;"	f
EchoFuncDisplay	.\echofunc.vim	/^function! s:EchoFuncDisplay()$/;"	f
EchoFuncGetStatusLine	.\echofunc.vim	/^function! EchoFuncGetStatusLine()$/;"	f
EchoFuncInitialize	.\echofunc.vim	/^function! s:EchoFuncInitialize()$/;"	f
EchoFuncN	.\echofunc.vim	/^function! EchoFuncN()$/;"	f
EchoFuncP	.\echofunc.vim	/^function! EchoFuncP()$/;"	f
EchoFuncPathMapping	.\echofunc.vim	/^func! s:EchoFuncPathMapping(path)$/;"	f
EchoFuncStart	.\echofunc.vim	/^function! EchoFuncStart()$/;"	f
EchoFuncStop	.\echofunc.vim	/^function! EchoFuncStop()$/;"	f
Gaussian	.\U3_9.py	/^    def Gaussian(self, mu, sigma, x):$/;"	m	class:robot
GetFuncName	.\echofunc.vim	/^function! s:GetFuncName(text)$/;"	f
GetFunctions	.\echofunc.vim	/^function! s:GetFunctions(fun, fn_only)$/;"	f
RestoreSettings	.\echofunc.vim	/^function! s:RestoreSettings()$/;"	f
__init__	.\U3_9.py	/^    def __init__(self):$/;"	m	class:robot
__repr__	.\U3_9.py	/^    def __repr__(self):$/;"	m	class:robot	file:
colors	.\U1_H4.py	/^colors = [['red', 'green', 'green', 'red' , 'red'],$/;"	v
division	.\U2_2.py	/^from __future__ import division$/;"	i
eval	.\U3_9.py	/^def eval(r, p):$/;"	f
flag	.\U2_2.py	/^            flag = False$/;"	v
flag	.\U2_2.py	/^    flag=True$/;"	v
g:EchoFuncAutoStartBalloonDeclaration	.\echofunc.vim	/^    let g:EchoFuncAutoStartBalloonDeclaration = 1$/;"	v
g:EchoFuncKeyNext	.\echofunc.vim	/^        let g:EchoFuncKeyNext='<M-=>'$/;"	v
g:EchoFuncKeyNext	.\echofunc.vim	/^        let g:EchoFuncKeyNext='≠'$/;"	v
g:EchoFuncKeyPrev	.\echofunc.vim	/^        let g:EchoFuncKeyPrev='<M-->'$/;"	v
g:EchoFuncKeyPrev	.\echofunc.vim	/^        let g:EchoFuncKeyPrev='±'$/;"	v
g:EchoFuncLangsDict	.\echofunc.vim	/^    let g:EchoFuncLangsDict={$/;"	v
g:EchoFuncLangsUsed	.\echofunc.vim	/^    let g:EchoFuncLangsUsed=sort(keys(g:EchoFuncLangsDict))$/;"	v
g:EchoFuncMaxBalloonDeclarations	.\echofunc.vim	/^    let g:EchoFuncMaxBalloonDeclarations=20$/;"	v
g:EchoFuncPathMapping	.\echofunc.vim	/^	let g:EchoFuncPathMapping = [$/;"	v
g:EchoFuncPathMappingEnabled	.\echofunc.vim	/^	let g:EchoFuncPathMappingEnabled = 1$/;"	v
g:EchoFuncShowOnStatus	.\echofunc.vim	/^    let g:EchoFuncShowOnStatus = 0$/;"	v
landmarks	.\U3_9.py	/^landmarks  = [[20.0, 20.0], [80.0, 80.0], [20.0, 80.0], [80.0, 20.0]]$/;"	v
measurement_prob	.\U3_9.py	/^    def measurement_prob(self, measurement):$/;"	m	class:robot
measurements	.\U1_15.py	/^measurements = ['red', 'green']$/;"	v
measurements	.\U1_17.py	/^measurements = ['red', 'green']$/;"	v
measurements	.\U1_24.py	/^measurements = ['red', 'green']$/;"	v
measurements	.\U1_H4.py	/^measurements = ['green', 'green', 'green' ,'green', 'green']$/;"	v
motions	.\U1_24.py	/^motions = [1,1]$/;"	v
motions	.\U1_H4.py	/^motions = [[0,0],[0,1],[1,0],[1,0],[0,1]]$/;"	v
move	.\U1_17.py	/^def move(p, U):$/;"	f
move	.\U1_24.py	/^def move(p, U):$/;"	f
move	.\U1_H4.py	/^def move(p, U):$/;"	f
move	.\U3_9.py	/^    def move(self, turn, forward):$/;"	m	class:robot
myrobot	.\U3_9.py	/^myrobot = robot()$/;"	v
p	.\U1_15.py	/^    p = sense(p, Z)$/;"	v
p	.\U1_15.py	/^p=[0.2, 0.2, 0.2, 0.2, 0.2]$/;"	v
p	.\U1_17.py	/^p=[0, 1, 0, 0, 0]$/;"	v
p	.\U1_24.py	/^    p=move(p,motions[i])$/;"	v
p	.\U1_24.py	/^    p=sense(p,measurements[i])$/;"	v
p	.\U1_24.py	/^p=[0.2, 0.2, 0.2, 0.2, 0.2]$/;"	v
p	.\U1_H4.py	/^    p=move(p,motions[i])$/;"	v
p	.\U1_H4.py	/^    p=sense(p,measurements[i])$/;"	v
p	.\U1_H4.py	/^p=[]$/;"	v
pExact	.\U1_24.py	/^pExact = 0.8$/;"	v
pHit	.\U1_15.py	/^pHit = 0.6$/;"	v
pHit	.\U1_17.py	/^pHit = 0.6$/;"	v
pHit	.\U1_24.py	/^pHit = 0.6$/;"	v
pMiss	.\U1_15.py	/^pMiss = 0.2$/;"	v
pMiss	.\U1_17.py	/^pMiss = 0.2$/;"	v
pMiss	.\U1_24.py	/^pMiss = 0.2$/;"	v
pOvershoot	.\U1_24.py	/^pOvershoot = 0.1$/;"	v
pOvershoot	.\U1_H4.py	/^pOvershoot=(1.0-p_move)\/2$/;"	v
pUndershoot	.\U1_24.py	/^pUndershoot = 0.1$/;"	v
pUndershoot	.\U1_H4.py	/^pUndershoot=pOvershoot$/;"	v
p_move	.\U1_H4.py	/^p_move = 0.8$/;"	v
random	.\U3_9.py	/^import random$/;"	i
remaind	.\U2_2.py	/^            remaind=(remaind-1)\/5*4$/;"	v
remaind	.\U2_2.py	/^    remaind=i$/;"	v
robot	.\U3_9.py	/^class robot:$/;"	c
s:count	.\echofunc.vim	/^let s:count=1$/;"	v
s:cpo_save	.\echofunc.vim	/^let s:cpo_save=&cpo$/;"	v
s:res	.\echofunc.vim	/^let s:res=[]$/;"	v
sense	.\U1_15.py	/^def sense(p, Z):$/;"	f
sense	.\U1_17.py	/^def sense(p, Z):$/;"	f
sense	.\U1_24.py	/^def sense(p, Z):$/;"	f
sense	.\U1_H4.py	/^def sense(p, Z):$/;"	f
sense	.\U3_9.py	/^    def sense(self):$/;"	m	class:robot
sensor_right	.\U1_H4.py	/^sensor_right = 0.7$/;"	v
set	.\U3_9.py	/^    def set(self, new_x, new_y, new_orientation):$/;"	m	class:robot
set_noise	.\U3_9.py	/^    def set_noise(self, new_f_noise, new_t_noise, new_s_noise):$/;"	m	class:robot
show	.\U1_H4.py	/^def show(p):$/;"	f
world	.\U1_15.py	/^world=['green', 'red', 'red', 'green', 'green']$/;"	v
world	.\U1_17.py	/^world=['green', 'red', 'red', 'green', 'green']$/;"	v
world	.\U1_24.py	/^world=['green', 'red', 'red', 'green', 'green']$/;"	v
world_size	.\U3_9.py	/^world_size = 100.0$/;"	v
